
test_FreeRTOS_blink-a-LED.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  00000d76  00000e0a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000d76  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000646  0080012e  0080012e  00000e38  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e38  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000e68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000228  00000000  00000000  00000ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002701  00000000  00000000  000010d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000825  00000000  00000000  000037d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000016c1  00000000  00000000  00003ff6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000660  00000000  00000000  000056b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d33  00000000  00000000  00005d18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000238b  00000000  00000000  00006a4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000250  00000000  00000000  00008dd6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	ee c2       	rjmp	.+1500   	; 0x60e <__vector_12>
  32:	00 00       	nop
  34:	48 c0       	rjmp	.+144    	; 0xc6 <__bad_interrupt>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 e7       	ldi	r30, 0x76	; 118
  a0:	fd e0       	ldi	r31, 0x0D	; 13
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ae 32       	cpi	r26, 0x2E	; 46
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	ae e2       	ldi	r26, 0x2E	; 46
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a4 37       	cpi	r26, 0x74	; 116
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	4a d0       	rcall	.+148    	; 0x158 <main>
  c4:	56 c6       	rjmp	.+3244   	; 0xd72 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <blink_Led_PA4>:
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,3);
	}
}
static void blink_Led_PA4(void *pvParameters) {
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	00 d0       	rcall	.+0      	; 0xce <blink_Led_PA4+0x6>
  ce:	cd b7       	in	r28, 0x3d	; 61
  d0:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  d2:	3c d4       	rcall	.+2168   	; 0x94c <xTaskGetTickCount>
  d4:	9a 83       	std	Y+2, r25	; 0x02
  d6:	89 83       	std	Y+1, r24	; 0x01
	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,4);
  d8:	10 e1       	ldi	r17, 0x10	; 16

	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
  da:	67 e7       	ldi	r22, 0x77	; 119
  dc:	71 e0       	ldi	r23, 0x01	; 1
  de:	ce 01       	movw	r24, r28
  e0:	01 96       	adiw	r24, 0x01	; 1
  e2:	6e d5       	rcall	.+2780   	; 0xbc0 <vTaskDelayUntil>
		pin_Toggle(A,4);
  e4:	8b b3       	in	r24, 0x1b	; 27
  e6:	81 27       	eor	r24, r17
  e8:	8b bb       	out	0x1b, r24	; 27
	}
  ea:	f7 cf       	rjmp	.-18     	; 0xda <blink_Led_PA4+0x12>

000000ec <blink_Led_PA3>:
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,2);
	}
}
static void blink_Led_PA3(void *pvParameters) {
  ec:	cf 93       	push	r28
  ee:	df 93       	push	r29
  f0:	00 d0       	rcall	.+0      	; 0xf2 <blink_Led_PA3+0x6>
  f2:	cd b7       	in	r28, 0x3d	; 61
  f4:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  f6:	2a d4       	rcall	.+2132   	; 0x94c <xTaskGetTickCount>
  f8:	9a 83       	std	Y+2, r25	; 0x02
  fa:	89 83       	std	Y+1, r24	; 0x01
	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,3);
  fc:	18 e0       	ldi	r17, 0x08	; 8

	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
  fe:	64 ef       	ldi	r22, 0xF4	; 244
 100:	71 e0       	ldi	r23, 0x01	; 1
 102:	ce 01       	movw	r24, r28
 104:	01 96       	adiw	r24, 0x01	; 1
 106:	5c d5       	rcall	.+2744   	; 0xbc0 <vTaskDelayUntil>
		pin_Toggle(A,3);
 108:	8b b3       	in	r24, 0x1b	; 27
 10a:	81 27       	eor	r24, r17
 10c:	8b bb       	out	0x1b, r24	; 27
	}
 10e:	f7 cf       	rjmp	.-18     	; 0xfe <blink_Led_PA3+0x12>

00000110 <blink_Led_PA2>:
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,1);
	}
}
static void blink_Led_PA2(void *pvParameters) {
 110:	cf 93       	push	r28
 112:	df 93       	push	r29
 114:	00 d0       	rcall	.+0      	; 0x116 <blink_Led_PA2+0x6>
 116:	cd b7       	in	r28, 0x3d	; 61
 118:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
 11a:	18 d4       	rcall	.+2096   	; 0x94c <xTaskGetTickCount>
 11c:	9a 83       	std	Y+2, r25	; 0x02
 11e:	89 83       	std	Y+1, r24	; 0x01
	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,2);
 120:	14 e0       	ldi	r17, 0x04	; 4

	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
 122:	6e ee       	ldi	r22, 0xEE	; 238
 124:	72 e0       	ldi	r23, 0x02	; 2
 126:	ce 01       	movw	r24, r28
 128:	01 96       	adiw	r24, 0x01	; 1
 12a:	4a d5       	rcall	.+2708   	; 0xbc0 <vTaskDelayUntil>
		pin_Toggle(A,2);
 12c:	8b b3       	in	r24, 0x1b	; 27
 12e:	81 27       	eor	r24, r17
 130:	8b bb       	out	0x1b, r24	; 27
	}
 132:	f7 cf       	rjmp	.-18     	; 0x122 <blink_Led_PA2+0x12>

00000134 <blink_Led_PA1>:
	return 0;
}

/*-----------------------------------------------------------*/

static void blink_Led_PA1(void *pvParameters) {
 134:	cf 93       	push	r28
 136:	df 93       	push	r29
 138:	00 d0       	rcall	.+0      	; 0x13a <blink_Led_PA1+0x6>
 13a:	cd b7       	in	r28, 0x3d	; 61
 13c:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
 13e:	06 d4       	rcall	.+2060   	; 0x94c <xTaskGetTickCount>
 140:	9a 83       	std	Y+2, r25	; 0x02
 142:	89 83       	std	Y+1, r24	; 0x01
	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
		pin_Toggle(A,1);
 144:	12 e0       	ldi	r17, 0x02	; 2

	(void)pvParameters; // parameters not used

	// forever loop
	while (1) {
		vTaskDelayUntil(&xLastWakeTime, delay/2);
 146:	6c ed       	ldi	r22, 0xDC	; 220
 148:	75 e0       	ldi	r23, 0x05	; 5
 14a:	ce 01       	movw	r24, r28
 14c:	01 96       	adiw	r24, 0x01	; 1
 14e:	38 d5       	rcall	.+2672   	; 0xbc0 <vTaskDelayUntil>
		pin_Toggle(A,1);
 150:	8b b3       	in	r24, 0x1b	; 27
 152:	81 27       	eor	r24, r17
 154:	8b bb       	out	0x1b, r24	; 27
	}
 156:	f7 cf       	rjmp	.-18     	; 0x146 <blink_Led_PA1+0x12>

00000158 <main>:
static void blink_Led_PA1(void *pvParameters);
static void blink_Led_PA2(void *pvParameters);
static void blink_Led_PA3(void *pvParameters);
static void blink_Led_PA4(void *pvParameters);

int main(void) {
 158:	ef 92       	push	r14
 15a:	ff 92       	push	r15
 15c:	0f 93       	push	r16
// initializare porturi
// Port A /   EXT_PA7  /  EXT_PA6  /  EXT_PA5  /  EXT_PA4  /  EXT_PA3  /  EXT_PA2  /  EXT_PA1  /  Far_out
	DDRA  = (1<<DDRA7) |(1<<DDRA6) |(1<<DDRA5) |(1<<DDRA4) |(1<<DDRA3) |(1<<DDRA2) |(1<<DDRA1) |(1<<DDRA0);
 15e:	8f ef       	ldi	r24, 0xFF	; 255
 160:	8a bb       	out	0x1a, r24	; 26
	PORTA = (0<<PORTA7)|(0<<PORTA6)|(0<<PORTA5)|(0<<PORTA4)|(0<<PORTA3)|(0<<PORTA2)|(0<<PORTA1)|(0<<PORTA0);
 162:	1b ba       	out	0x1b, r1	; 27

// Port B /    OC1C    /   OC1B    /   OC1A    /    OC0    /           /           /     -     /
	DDRB  = (1<<DDRB7) |(1<<DDRB6) |(1<<DDRB5) |(0<<DDRB4) |(0<<DDRB3) |(0<<DDRB2) |(0<<DDRB1) |(0<<DDRB0);
 164:	80 ee       	ldi	r24, 0xE0	; 224
 166:	87 bb       	out	0x17, r24	; 23
	PORTB = (0<<PORTB7)|(0<<PORTB6)|(0<<PORTB5)|(0<<PORTB4)|(0<<PORTB3)|(0<<PORTB2)|(0<<PORTB1)|(0<<PORTB0);
 168:	18 ba       	out	0x18, r1	; 24

// Port C /   EXT_PC7  /  EXT_PC6  /  EXT_PC5  /  EXT_PC4  /  EXT_PC3  /  EXT_PC2  /  EXT_PC1  /  EXT_PC0
	DDRC  = (0<<DDRC7) |(0<<DDRC6) |(0<<DDRC5) |(0<<DDRC4) |(0<<DDRC3) |(0<<DDRC2) |(0<<DDRC1) |(0<<DDRC0);
 16a:	14 ba       	out	0x14, r1	; 20
	PORTC = (0<<PORTC7)|(0<<PORTC6)|(0<<PORTC5)|(0<<PORTC4)|(0<<PORTC3)|(1<<PORTC2)|(1<<PORTC1)|(1<<PORTC0);
 16c:	87 e0       	ldi	r24, 0x07	; 7
 16e:	85 bb       	out	0x15, r24	; 21

// Port D /    Sig_R   /   Sig_L   /   Brake   /  Far_in   /   TxD1    /   RxD1    /  Hall_A   / Led_test
	DDRD  = (0<<DDRD7) |(0<<DDRD6) |(0<<DDRD5) |(0<<DDRD4) |(1<<DDRD3) |(0<<DDRD2) |(0<<DDRD1) |(1<<DDRD0);
 170:	89 e0       	ldi	r24, 0x09	; 9
 172:	81 bb       	out	0x11, r24	; 17
	PORTD = (1<<PORTD7)|(1<<PORTD6)|(1<<PORTD5)|(1<<PORTD4)|(0<<PORTD3)|(0<<PORTD2)|(1<<PORTD1)|(0<<PORTD0);
 174:	82 ef       	ldi	r24, 0xF2	; 242
 176:	82 bb       	out	0x12, r24	; 18

// Port E /   Hall_C   /  Hall_B   /   OC3C    /   OC3B    /   OC3A    /           /           /
	DDRE  = (0<<DDRE7) |(0<<DDRE6) |(1<<DDRE5) |(1<<DDRE4) |(1<<DDRE3) |(0<<DDRE2) |(0<<DDRE1) |(0<<DDRE0);
 178:	88 e3       	ldi	r24, 0x38	; 56
 17a:	82 b9       	out	0x02, r24	; 2
	PORTE = (1<<PORTE7)|(1<<PORTE6)|(0<<PORTE5)|(0<<PORTE4)|(0<<PORTE3)|(0<<PORTE2)|(0<<PORTE1)|(0<<PORTE0);
 17c:	80 ec       	ldi	r24, 0xC0	; 192
 17e:	83 b9       	out	0x03, r24	; 3

// Port F /  Throttle  /   ADC6    /   ADC5    /   ADC4    /   ADC3    /   VBAT    /  ASENSE   /   TEMP
	DDRF  = (0<<DDRF7) |(0<<DDRF6) |(0<<DDRF5) |(0<<DDRF4) |(0<<DDRF3) |(0<<DDRF2) |(0<<DDRF1) |(0<<DDRF0);
 180:	10 92 61 00 	sts	0x0061, r1
	PORTF = (0<<PORTF7)|(0<<PORTF6)|(0<<PORTF5)|(0<<PORTF4)|(0<<PORTF3)|(0<<PORTF2)|(0<<PORTF1)|(0<<PORTF0);
 184:	10 92 62 00 	sts	0x0062, r1

// Port G neconectat
	DDRG  = 0x00;
 188:	10 92 64 00 	sts	0x0064, r1
	PORTG = 0x00;
 18c:	10 92 65 00 	sts	0x0065, r1

	// create blinking task
	xTaskCreate(blink_Led_PA1, "blink_PA1", configMINIMAL_STACK_SIZE, NULL, 1, NULL); // LED pe PORTA1; 1Hz
 190:	e1 2c       	mov	r14, r1
 192:	f1 2c       	mov	r15, r1
 194:	01 e0       	ldi	r16, 0x01	; 1
 196:	20 e0       	ldi	r18, 0x00	; 0
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	45 e5       	ldi	r20, 0x55	; 85
 19c:	50 e0       	ldi	r21, 0x00	; 0
 19e:	60 e0       	ldi	r22, 0x00	; 0
 1a0:	71 e0       	ldi	r23, 0x01	; 1
 1a2:	8a e9       	ldi	r24, 0x9A	; 154
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	a8 d2       	rcall	.+1360   	; 0x6f8 <xTaskCreate>
	xTaskCreate(blink_Led_PA2, "blink_PA2", configMINIMAL_STACK_SIZE, NULL, 1, NULL); // LED pe PORTA2; 2Hz
 1a8:	20 e0       	ldi	r18, 0x00	; 0
 1aa:	30 e0       	ldi	r19, 0x00	; 0
 1ac:	45 e5       	ldi	r20, 0x55	; 85
 1ae:	50 e0       	ldi	r21, 0x00	; 0
 1b0:	6a e0       	ldi	r22, 0x0A	; 10
 1b2:	71 e0       	ldi	r23, 0x01	; 1
 1b4:	88 e8       	ldi	r24, 0x88	; 136
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	9f d2       	rcall	.+1342   	; 0x6f8 <xTaskCreate>
	xTaskCreate(blink_Led_PA3, "blink_PA3", configMINIMAL_STACK_SIZE, NULL, 1, NULL); // LED pe PORTA3; 3Hz
 1ba:	20 e0       	ldi	r18, 0x00	; 0
 1bc:	30 e0       	ldi	r19, 0x00	; 0
 1be:	45 e5       	ldi	r20, 0x55	; 85
 1c0:	50 e0       	ldi	r21, 0x00	; 0
 1c2:	64 e1       	ldi	r22, 0x14	; 20
 1c4:	71 e0       	ldi	r23, 0x01	; 1
 1c6:	86 e7       	ldi	r24, 0x76	; 118
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	96 d2       	rcall	.+1324   	; 0x6f8 <xTaskCreate>
	xTaskCreate(blink_Led_PA4, "blink_PA4", configMINIMAL_STACK_SIZE, NULL, 1, NULL); // LED pe PORTA4; 4Hz
 1cc:	20 e0       	ldi	r18, 0x00	; 0
 1ce:	30 e0       	ldi	r19, 0x00	; 0
 1d0:	45 e5       	ldi	r20, 0x55	; 85
 1d2:	50 e0       	ldi	r21, 0x00	; 0
 1d4:	6e e1       	ldi	r22, 0x1E	; 30
 1d6:	71 e0       	ldi	r23, 0x01	; 1
 1d8:	84 e6       	ldi	r24, 0x64	; 100
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	8d d2       	rcall	.+1306   	; 0x6f8 <xTaskCreate>

	// start the scheduler
	vTaskStartScheduler();
 1de:	88 d3       	rcall	.+1808   	; 0x8f0 <vTaskStartScheduler>

	return 0;
}
 1e0:	80 e0       	ldi	r24, 0x00	; 0
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	0f 91       	pop	r16
 1e6:	ff 90       	pop	r15
 1e8:	ef 90       	pop	r14
 1ea:	08 95       	ret

000001ec <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1ec:	cf 93       	push	r28
 1ee:	df 93       	push	r29
 1f0:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 1f2:	a6 d3       	rcall	.+1868   	; 0x940 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 1f4:	80 91 2e 01 	lds	r24, 0x012E
 1f8:	90 91 2f 01 	lds	r25, 0x012F
 1fc:	89 2b       	or	r24, r25
 1fe:	31 f4       	brne	.+12     	; 0x20c <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 200:	83 e3       	ldi	r24, 0x33	; 51
 202:	91 e0       	ldi	r25, 0x01	; 1
 204:	90 93 2f 01 	sts	0x012F, r25
 208:	80 93 2e 01 	sts	0x012E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 20c:	20 91 30 01 	lds	r18, 0x0130
 210:	30 91 31 01 	lds	r19, 0x0131
 214:	ce 01       	movw	r24, r28
 216:	82 0f       	add	r24, r18
 218:	93 1f       	adc	r25, r19
 21a:	8b 3d       	cpi	r24, 0xDB	; 219
 21c:	45 e0       	ldi	r20, 0x05	; 5
 21e:	94 07       	cpc	r25, r20
 220:	70 f4       	brcc	.+28     	; 0x23e <pvPortMalloc+0x52>
 222:	28 17       	cp	r18, r24
 224:	39 07       	cpc	r19, r25
 226:	70 f4       	brcc	.+28     	; 0x244 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 228:	c0 91 2e 01 	lds	r28, 0x012E
 22c:	d0 91 2f 01 	lds	r29, 0x012F
 230:	c2 0f       	add	r28, r18
 232:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 234:	90 93 31 01 	sts	0x0131, r25
 238:	80 93 30 01 	sts	0x0130, r24
 23c:	05 c0       	rjmp	.+10     	; 0x248 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 23e:	c0 e0       	ldi	r28, 0x00	; 0
 240:	d0 e0       	ldi	r29, 0x00	; 0
 242:	02 c0       	rjmp	.+4      	; 0x248 <pvPortMalloc+0x5c>
 244:	c0 e0       	ldi	r28, 0x00	; 0
 246:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 248:	42 d4       	rcall	.+2180   	; 0xace <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 24a:	ce 01       	movw	r24, r28
 24c:	df 91       	pop	r29
 24e:	cf 91       	pop	r28
 250:	08 95       	ret

00000252 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 252:	08 95       	ret

00000254 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 254:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 256:	03 96       	adiw	r24, 0x03	; 3
 258:	92 83       	std	Z+2, r25	; 0x02
 25a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 25c:	2f ef       	ldi	r18, 0xFF	; 255
 25e:	3f ef       	ldi	r19, 0xFF	; 255
 260:	34 83       	std	Z+4, r19	; 0x04
 262:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 264:	96 83       	std	Z+6, r25	; 0x06
 266:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 268:	90 87       	std	Z+8, r25	; 0x08
 26a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 26c:	10 82       	st	Z, r1
 26e:	08 95       	ret

00000270 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 270:	fc 01       	movw	r30, r24
 272:	11 86       	std	Z+9, r1	; 0x09
 274:	10 86       	std	Z+8, r1	; 0x08
 276:	08 95       	ret

00000278 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29
 27c:	9c 01       	movw	r18, r24
 27e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 280:	dc 01       	movw	r26, r24
 282:	11 96       	adiw	r26, 0x01	; 1
 284:	cd 91       	ld	r28, X+
 286:	dc 91       	ld	r29, X
 288:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 28a:	d3 83       	std	Z+3, r29	; 0x03
 28c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 28e:	8c 81       	ldd	r24, Y+4	; 0x04
 290:	9d 81       	ldd	r25, Y+5	; 0x05
 292:	95 83       	std	Z+5, r25	; 0x05
 294:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 296:	8c 81       	ldd	r24, Y+4	; 0x04
 298:	9d 81       	ldd	r25, Y+5	; 0x05
 29a:	dc 01       	movw	r26, r24
 29c:	13 96       	adiw	r26, 0x03	; 3
 29e:	7c 93       	st	X, r23
 2a0:	6e 93       	st	-X, r22
 2a2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 2a4:	7d 83       	std	Y+5, r23	; 0x05
 2a6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2a8:	31 87       	std	Z+9, r19	; 0x09
 2aa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 2ac:	f9 01       	movw	r30, r18
 2ae:	80 81       	ld	r24, Z
 2b0:	8f 5f       	subi	r24, 0xFF	; 255
 2b2:	80 83       	st	Z, r24
}
 2b4:	df 91       	pop	r29
 2b6:	cf 91       	pop	r28
 2b8:	08 95       	ret

000002ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 2ba:	cf 93       	push	r28
 2bc:	df 93       	push	r29
 2be:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 2c0:	48 81       	ld	r20, Y
 2c2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 2c4:	4f 3f       	cpi	r20, 0xFF	; 255
 2c6:	2f ef       	ldi	r18, 0xFF	; 255
 2c8:	52 07       	cpc	r21, r18
 2ca:	21 f4       	brne	.+8      	; 0x2d4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 2cc:	fc 01       	movw	r30, r24
 2ce:	a7 81       	ldd	r26, Z+7	; 0x07
 2d0:	b0 85       	ldd	r27, Z+8	; 0x08
 2d2:	0d c0       	rjmp	.+26     	; 0x2ee <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2d4:	dc 01       	movw	r26, r24
 2d6:	13 96       	adiw	r26, 0x03	; 3
 2d8:	01 c0       	rjmp	.+2      	; 0x2dc <vListInsert+0x22>
 2da:	df 01       	movw	r26, r30
 2dc:	12 96       	adiw	r26, 0x02	; 2
 2de:	ed 91       	ld	r30, X+
 2e0:	fc 91       	ld	r31, X
 2e2:	13 97       	sbiw	r26, 0x03	; 3
 2e4:	20 81       	ld	r18, Z
 2e6:	31 81       	ldd	r19, Z+1	; 0x01
 2e8:	42 17       	cp	r20, r18
 2ea:	53 07       	cpc	r21, r19
 2ec:	b0 f7       	brcc	.-20     	; 0x2da <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2ee:	12 96       	adiw	r26, 0x02	; 2
 2f0:	ed 91       	ld	r30, X+
 2f2:	fc 91       	ld	r31, X
 2f4:	13 97       	sbiw	r26, 0x03	; 3
 2f6:	fb 83       	std	Y+3, r31	; 0x03
 2f8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 2fa:	d5 83       	std	Z+5, r29	; 0x05
 2fc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 2fe:	bd 83       	std	Y+5, r27	; 0x05
 300:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 302:	13 96       	adiw	r26, 0x03	; 3
 304:	dc 93       	st	X, r29
 306:	ce 93       	st	-X, r28
 308:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 30a:	99 87       	std	Y+9, r25	; 0x09
 30c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 30e:	fc 01       	movw	r30, r24
 310:	20 81       	ld	r18, Z
 312:	2f 5f       	subi	r18, 0xFF	; 255
 314:	20 83       	st	Z, r18
}
 316:	df 91       	pop	r29
 318:	cf 91       	pop	r28
 31a:	08 95       	ret

0000031c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 31c:	cf 93       	push	r28
 31e:	df 93       	push	r29
 320:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 322:	a0 85       	ldd	r26, Z+8	; 0x08
 324:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 326:	c2 81       	ldd	r28, Z+2	; 0x02
 328:	d3 81       	ldd	r29, Z+3	; 0x03
 32a:	84 81       	ldd	r24, Z+4	; 0x04
 32c:	95 81       	ldd	r25, Z+5	; 0x05
 32e:	9d 83       	std	Y+5, r25	; 0x05
 330:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 332:	c4 81       	ldd	r28, Z+4	; 0x04
 334:	d5 81       	ldd	r29, Z+5	; 0x05
 336:	82 81       	ldd	r24, Z+2	; 0x02
 338:	93 81       	ldd	r25, Z+3	; 0x03
 33a:	9b 83       	std	Y+3, r25	; 0x03
 33c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 33e:	11 96       	adiw	r26, 0x01	; 1
 340:	cd 91       	ld	r28, X+
 342:	dc 91       	ld	r29, X
 344:	12 97       	sbiw	r26, 0x02	; 2
 346:	ce 17       	cp	r28, r30
 348:	df 07       	cpc	r29, r31
 34a:	31 f4       	brne	.+12     	; 0x358 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 34c:	8c 81       	ldd	r24, Y+4	; 0x04
 34e:	9d 81       	ldd	r25, Y+5	; 0x05
 350:	12 96       	adiw	r26, 0x02	; 2
 352:	9c 93       	st	X, r25
 354:	8e 93       	st	-X, r24
 356:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 358:	11 86       	std	Z+9, r1	; 0x09
 35a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 35c:	8c 91       	ld	r24, X
 35e:	81 50       	subi	r24, 0x01	; 1
 360:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 362:	df 91       	pop	r29
 364:	cf 91       	pop	r28
 366:	08 95       	ret

00000368 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 368:	31 e1       	ldi	r19, 0x11	; 17
 36a:	fc 01       	movw	r30, r24
 36c:	30 83       	st	Z, r19
 36e:	31 97       	sbiw	r30, 0x01	; 1
 370:	22 e2       	ldi	r18, 0x22	; 34
 372:	20 83       	st	Z, r18
 374:	31 97       	sbiw	r30, 0x01	; 1
 376:	a3 e3       	ldi	r26, 0x33	; 51
 378:	a0 83       	st	Z, r26
 37a:	31 97       	sbiw	r30, 0x01	; 1
 37c:	60 83       	st	Z, r22
 37e:	31 97       	sbiw	r30, 0x01	; 1
 380:	70 83       	st	Z, r23
 382:	31 97       	sbiw	r30, 0x01	; 1
 384:	10 82       	st	Z, r1
 386:	31 97       	sbiw	r30, 0x01	; 1
 388:	60 e8       	ldi	r22, 0x80	; 128
 38a:	60 83       	st	Z, r22
 38c:	31 97       	sbiw	r30, 0x01	; 1
 38e:	10 82       	st	Z, r1
 390:	31 97       	sbiw	r30, 0x01	; 1
 392:	62 e0       	ldi	r22, 0x02	; 2
 394:	60 83       	st	Z, r22
 396:	31 97       	sbiw	r30, 0x01	; 1
 398:	63 e0       	ldi	r22, 0x03	; 3
 39a:	60 83       	st	Z, r22
 39c:	31 97       	sbiw	r30, 0x01	; 1
 39e:	64 e0       	ldi	r22, 0x04	; 4
 3a0:	60 83       	st	Z, r22
 3a2:	31 97       	sbiw	r30, 0x01	; 1
 3a4:	65 e0       	ldi	r22, 0x05	; 5
 3a6:	60 83       	st	Z, r22
 3a8:	31 97       	sbiw	r30, 0x01	; 1
 3aa:	66 e0       	ldi	r22, 0x06	; 6
 3ac:	60 83       	st	Z, r22
 3ae:	31 97       	sbiw	r30, 0x01	; 1
 3b0:	67 e0       	ldi	r22, 0x07	; 7
 3b2:	60 83       	st	Z, r22
 3b4:	31 97       	sbiw	r30, 0x01	; 1
 3b6:	68 e0       	ldi	r22, 0x08	; 8
 3b8:	60 83       	st	Z, r22
 3ba:	31 97       	sbiw	r30, 0x01	; 1
 3bc:	69 e0       	ldi	r22, 0x09	; 9
 3be:	60 83       	st	Z, r22
 3c0:	31 97       	sbiw	r30, 0x01	; 1
 3c2:	60 e1       	ldi	r22, 0x10	; 16
 3c4:	60 83       	st	Z, r22
 3c6:	31 97       	sbiw	r30, 0x01	; 1
 3c8:	30 83       	st	Z, r19
 3ca:	31 97       	sbiw	r30, 0x01	; 1
 3cc:	32 e1       	ldi	r19, 0x12	; 18
 3ce:	30 83       	st	Z, r19
 3d0:	31 97       	sbiw	r30, 0x01	; 1
 3d2:	33 e1       	ldi	r19, 0x13	; 19
 3d4:	30 83       	st	Z, r19
 3d6:	31 97       	sbiw	r30, 0x01	; 1
 3d8:	34 e1       	ldi	r19, 0x14	; 20
 3da:	30 83       	st	Z, r19
 3dc:	31 97       	sbiw	r30, 0x01	; 1
 3de:	35 e1       	ldi	r19, 0x15	; 21
 3e0:	30 83       	st	Z, r19
 3e2:	31 97       	sbiw	r30, 0x01	; 1
 3e4:	36 e1       	ldi	r19, 0x16	; 22
 3e6:	30 83       	st	Z, r19
 3e8:	31 97       	sbiw	r30, 0x01	; 1
 3ea:	37 e1       	ldi	r19, 0x17	; 23
 3ec:	30 83       	st	Z, r19
 3ee:	31 97       	sbiw	r30, 0x01	; 1
 3f0:	38 e1       	ldi	r19, 0x18	; 24
 3f2:	30 83       	st	Z, r19
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	39 e1       	ldi	r19, 0x19	; 25
 3f8:	30 83       	st	Z, r19
 3fa:	31 97       	sbiw	r30, 0x01	; 1
 3fc:	30 e2       	ldi	r19, 0x20	; 32
 3fe:	30 83       	st	Z, r19
 400:	31 97       	sbiw	r30, 0x01	; 1
 402:	31 e2       	ldi	r19, 0x21	; 33
 404:	30 83       	st	Z, r19
 406:	31 97       	sbiw	r30, 0x01	; 1
 408:	20 83       	st	Z, r18
 40a:	31 97       	sbiw	r30, 0x01	; 1
 40c:	23 e2       	ldi	r18, 0x23	; 35
 40e:	20 83       	st	Z, r18
 410:	31 97       	sbiw	r30, 0x01	; 1
 412:	40 83       	st	Z, r20
 414:	31 97       	sbiw	r30, 0x01	; 1
 416:	50 83       	st	Z, r21
 418:	31 97       	sbiw	r30, 0x01	; 1
 41a:	26 e2       	ldi	r18, 0x26	; 38
 41c:	20 83       	st	Z, r18
 41e:	31 97       	sbiw	r30, 0x01	; 1
 420:	27 e2       	ldi	r18, 0x27	; 39
 422:	20 83       	st	Z, r18
 424:	31 97       	sbiw	r30, 0x01	; 1
 426:	28 e2       	ldi	r18, 0x28	; 40
 428:	20 83       	st	Z, r18
 42a:	31 97       	sbiw	r30, 0x01	; 1
 42c:	29 e2       	ldi	r18, 0x29	; 41
 42e:	20 83       	st	Z, r18
 430:	31 97       	sbiw	r30, 0x01	; 1
 432:	20 e3       	ldi	r18, 0x30	; 48
 434:	20 83       	st	Z, r18
 436:	31 97       	sbiw	r30, 0x01	; 1
 438:	21 e3       	ldi	r18, 0x31	; 49
 43a:	20 83       	st	Z, r18
 43c:	86 97       	sbiw	r24, 0x26	; 38
 43e:	08 95       	ret

00000440 <xPortStartScheduler>:
 440:	1b bc       	out	0x2b, r1	; 43
 442:	82 e5       	ldi	r24, 0x52	; 82
 444:	8a bd       	out	0x2a, r24	; 42
 446:	8b e0       	ldi	r24, 0x0B	; 11
 448:	8e bd       	out	0x2e, r24	; 46
 44a:	87 b7       	in	r24, 0x37	; 55
 44c:	80 61       	ori	r24, 0x10	; 16
 44e:	87 bf       	out	0x37, r24	; 55
 450:	a0 91 72 07 	lds	r26, 0x0772
 454:	b0 91 73 07 	lds	r27, 0x0773
 458:	cd 91       	ld	r28, X+
 45a:	cd bf       	out	0x3d, r28	; 61
 45c:	dd 91       	ld	r29, X+
 45e:	de bf       	out	0x3e, r29	; 62
 460:	ff 91       	pop	r31
 462:	ef 91       	pop	r30
 464:	df 91       	pop	r29
 466:	cf 91       	pop	r28
 468:	bf 91       	pop	r27
 46a:	af 91       	pop	r26
 46c:	9f 91       	pop	r25
 46e:	8f 91       	pop	r24
 470:	7f 91       	pop	r23
 472:	6f 91       	pop	r22
 474:	5f 91       	pop	r21
 476:	4f 91       	pop	r20
 478:	3f 91       	pop	r19
 47a:	2f 91       	pop	r18
 47c:	1f 91       	pop	r17
 47e:	0f 91       	pop	r16
 480:	ff 90       	pop	r15
 482:	ef 90       	pop	r14
 484:	df 90       	pop	r13
 486:	cf 90       	pop	r12
 488:	bf 90       	pop	r11
 48a:	af 90       	pop	r10
 48c:	9f 90       	pop	r9
 48e:	8f 90       	pop	r8
 490:	7f 90       	pop	r7
 492:	6f 90       	pop	r6
 494:	5f 90       	pop	r5
 496:	4f 90       	pop	r4
 498:	3f 90       	pop	r3
 49a:	2f 90       	pop	r2
 49c:	1f 90       	pop	r1
 49e:	0f 90       	pop	r0
 4a0:	0f be       	out	0x3f, r0	; 63
 4a2:	0f 90       	pop	r0
 4a4:	08 95       	ret
 4a6:	81 e0       	ldi	r24, 0x01	; 1
 4a8:	08 95       	ret

000004aa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 4aa:	0f 92       	push	r0
 4ac:	0f b6       	in	r0, 0x3f	; 63
 4ae:	f8 94       	cli
 4b0:	0f 92       	push	r0
 4b2:	1f 92       	push	r1
 4b4:	11 24       	eor	r1, r1
 4b6:	2f 92       	push	r2
 4b8:	3f 92       	push	r3
 4ba:	4f 92       	push	r4
 4bc:	5f 92       	push	r5
 4be:	6f 92       	push	r6
 4c0:	7f 92       	push	r7
 4c2:	8f 92       	push	r8
 4c4:	9f 92       	push	r9
 4c6:	af 92       	push	r10
 4c8:	bf 92       	push	r11
 4ca:	cf 92       	push	r12
 4cc:	df 92       	push	r13
 4ce:	ef 92       	push	r14
 4d0:	ff 92       	push	r15
 4d2:	0f 93       	push	r16
 4d4:	1f 93       	push	r17
 4d6:	2f 93       	push	r18
 4d8:	3f 93       	push	r19
 4da:	4f 93       	push	r20
 4dc:	5f 93       	push	r21
 4de:	6f 93       	push	r22
 4e0:	7f 93       	push	r23
 4e2:	8f 93       	push	r24
 4e4:	9f 93       	push	r25
 4e6:	af 93       	push	r26
 4e8:	bf 93       	push	r27
 4ea:	cf 93       	push	r28
 4ec:	df 93       	push	r29
 4ee:	ef 93       	push	r30
 4f0:	ff 93       	push	r31
 4f2:	a0 91 72 07 	lds	r26, 0x0772
 4f6:	b0 91 73 07 	lds	r27, 0x0773
 4fa:	0d b6       	in	r0, 0x3d	; 61
 4fc:	0d 92       	st	X+, r0
 4fe:	0e b6       	in	r0, 0x3e	; 62
 500:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 502:	d1 d3       	rcall	.+1954   	; 0xca6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 504:	a0 91 72 07 	lds	r26, 0x0772
 508:	b0 91 73 07 	lds	r27, 0x0773
 50c:	cd 91       	ld	r28, X+
 50e:	cd bf       	out	0x3d, r28	; 61
 510:	dd 91       	ld	r29, X+
 512:	de bf       	out	0x3e, r29	; 62
 514:	ff 91       	pop	r31
 516:	ef 91       	pop	r30
 518:	df 91       	pop	r29
 51a:	cf 91       	pop	r28
 51c:	bf 91       	pop	r27
 51e:	af 91       	pop	r26
 520:	9f 91       	pop	r25
 522:	8f 91       	pop	r24
 524:	7f 91       	pop	r23
 526:	6f 91       	pop	r22
 528:	5f 91       	pop	r21
 52a:	4f 91       	pop	r20
 52c:	3f 91       	pop	r19
 52e:	2f 91       	pop	r18
 530:	1f 91       	pop	r17
 532:	0f 91       	pop	r16
 534:	ff 90       	pop	r15
 536:	ef 90       	pop	r14
 538:	df 90       	pop	r13
 53a:	cf 90       	pop	r12
 53c:	bf 90       	pop	r11
 53e:	af 90       	pop	r10
 540:	9f 90       	pop	r9
 542:	8f 90       	pop	r8
 544:	7f 90       	pop	r7
 546:	6f 90       	pop	r6
 548:	5f 90       	pop	r5
 54a:	4f 90       	pop	r4
 54c:	3f 90       	pop	r3
 54e:	2f 90       	pop	r2
 550:	1f 90       	pop	r1
 552:	0f 90       	pop	r0
 554:	0f be       	out	0x3f, r0	; 63
 556:	0f 90       	pop	r0

	asm volatile ( "ret" );
 558:	08 95       	ret

0000055a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 55a:	0f 92       	push	r0
 55c:	0f b6       	in	r0, 0x3f	; 63
 55e:	f8 94       	cli
 560:	0f 92       	push	r0
 562:	1f 92       	push	r1
 564:	11 24       	eor	r1, r1
 566:	2f 92       	push	r2
 568:	3f 92       	push	r3
 56a:	4f 92       	push	r4
 56c:	5f 92       	push	r5
 56e:	6f 92       	push	r6
 570:	7f 92       	push	r7
 572:	8f 92       	push	r8
 574:	9f 92       	push	r9
 576:	af 92       	push	r10
 578:	bf 92       	push	r11
 57a:	cf 92       	push	r12
 57c:	df 92       	push	r13
 57e:	ef 92       	push	r14
 580:	ff 92       	push	r15
 582:	0f 93       	push	r16
 584:	1f 93       	push	r17
 586:	2f 93       	push	r18
 588:	3f 93       	push	r19
 58a:	4f 93       	push	r20
 58c:	5f 93       	push	r21
 58e:	6f 93       	push	r22
 590:	7f 93       	push	r23
 592:	8f 93       	push	r24
 594:	9f 93       	push	r25
 596:	af 93       	push	r26
 598:	bf 93       	push	r27
 59a:	cf 93       	push	r28
 59c:	df 93       	push	r29
 59e:	ef 93       	push	r30
 5a0:	ff 93       	push	r31
 5a2:	a0 91 72 07 	lds	r26, 0x0772
 5a6:	b0 91 73 07 	lds	r27, 0x0773
 5aa:	0d b6       	in	r0, 0x3d	; 61
 5ac:	0d 92       	st	X+, r0
 5ae:	0e b6       	in	r0, 0x3e	; 62
 5b0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 5b2:	d6 d1       	rcall	.+940    	; 0x960 <xTaskIncrementTick>
 5b4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 5b6:	77 d3       	rcall	.+1774   	; 0xca6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 5b8:	a0 91 72 07 	lds	r26, 0x0772
 5bc:	b0 91 73 07 	lds	r27, 0x0773
 5c0:	cd 91       	ld	r28, X+
 5c2:	cd bf       	out	0x3d, r28	; 61
 5c4:	dd 91       	ld	r29, X+
 5c6:	de bf       	out	0x3e, r29	; 62
 5c8:	ff 91       	pop	r31
 5ca:	ef 91       	pop	r30
 5cc:	df 91       	pop	r29
 5ce:	cf 91       	pop	r28
 5d0:	bf 91       	pop	r27
 5d2:	af 91       	pop	r26
 5d4:	9f 91       	pop	r25
 5d6:	8f 91       	pop	r24
 5d8:	7f 91       	pop	r23
 5da:	6f 91       	pop	r22
 5dc:	5f 91       	pop	r21
 5de:	4f 91       	pop	r20
 5e0:	3f 91       	pop	r19
 5e2:	2f 91       	pop	r18
 5e4:	1f 91       	pop	r17
 5e6:	0f 91       	pop	r16
 5e8:	ff 90       	pop	r15
 5ea:	ef 90       	pop	r14
 5ec:	df 90       	pop	r13
 5ee:	cf 90       	pop	r12
 5f0:	bf 90       	pop	r11
 5f2:	af 90       	pop	r10
 5f4:	9f 90       	pop	r9
 5f6:	8f 90       	pop	r8
 5f8:	7f 90       	pop	r7
 5fa:	6f 90       	pop	r6
 5fc:	5f 90       	pop	r5
 5fe:	4f 90       	pop	r4
 600:	3f 90       	pop	r3
 602:	2f 90       	pop	r2
 604:	1f 90       	pop	r1
 606:	0f 90       	pop	r0
 608:	0f be       	out	0x3f, r0	; 63
 60a:	0f 90       	pop	r0

	asm volatile ( "ret" );
 60c:	08 95       	ret

0000060e <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 60e:	a5 df       	rcall	.-182    	; 0x55a <vPortYieldFromTick>
		asm volatile ( "reti" );
 610:	18 95       	reti

00000612 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 612:	e0 91 3a 07 	lds	r30, 0x073A
 616:	f0 91 3b 07 	lds	r31, 0x073B
 61a:	80 81       	ld	r24, Z
 61c:	81 11       	cpse	r24, r1
 61e:	07 c0       	rjmp	.+14     	; 0x62e <prvResetNextTaskUnblockTime+0x1c>
 620:	8f ef       	ldi	r24, 0xFF	; 255
 622:	9f ef       	ldi	r25, 0xFF	; 255
 624:	90 93 12 07 	sts	0x0712, r25
 628:	80 93 11 07 	sts	0x0711, r24
 62c:	08 95       	ret
 62e:	e0 91 3a 07 	lds	r30, 0x073A
 632:	f0 91 3b 07 	lds	r31, 0x073B
 636:	05 80       	ldd	r0, Z+5	; 0x05
 638:	f6 81       	ldd	r31, Z+6	; 0x06
 63a:	e0 2d       	mov	r30, r0
 63c:	06 80       	ldd	r0, Z+6	; 0x06
 63e:	f7 81       	ldd	r31, Z+7	; 0x07
 640:	e0 2d       	mov	r30, r0
 642:	82 81       	ldd	r24, Z+2	; 0x02
 644:	93 81       	ldd	r25, Z+3	; 0x03
 646:	90 93 12 07 	sts	0x0712, r25
 64a:	80 93 11 07 	sts	0x0711, r24
 64e:	08 95       	ret

00000650 <prvAddCurrentTaskToDelayedList>:
 650:	ff 92       	push	r15
 652:	0f 93       	push	r16
 654:	1f 93       	push	r17
 656:	cf 93       	push	r28
 658:	df 93       	push	r29
 65a:	ec 01       	movw	r28, r24
 65c:	f6 2e       	mov	r15, r22
 65e:	00 91 19 07 	lds	r16, 0x0719
 662:	10 91 1a 07 	lds	r17, 0x071A
 666:	80 91 72 07 	lds	r24, 0x0772
 66a:	90 91 73 07 	lds	r25, 0x0773
 66e:	02 96       	adiw	r24, 0x02	; 2
 670:	55 de       	rcall	.-854    	; 0x31c <uxListRemove>
 672:	cf 3f       	cpi	r28, 0xFF	; 255
 674:	8f ef       	ldi	r24, 0xFF	; 255
 676:	d8 07       	cpc	r29, r24
 678:	61 f4       	brne	.+24     	; 0x692 <prvAddCurrentTaskToDelayedList+0x42>
 67a:	ff 20       	and	r15, r15
 67c:	51 f0       	breq	.+20     	; 0x692 <prvAddCurrentTaskToDelayedList+0x42>
 67e:	60 91 72 07 	lds	r22, 0x0772
 682:	70 91 73 07 	lds	r23, 0x0773
 686:	6e 5f       	subi	r22, 0xFE	; 254
 688:	7f 4f       	sbci	r23, 0xFF	; 255
 68a:	8c e1       	ldi	r24, 0x1C	; 28
 68c:	97 e0       	ldi	r25, 0x07	; 7
 68e:	f4 dd       	rcall	.-1048   	; 0x278 <vListInsertEnd>
 690:	2d c0       	rjmp	.+90     	; 0x6ec <prvAddCurrentTaskToDelayedList+0x9c>
 692:	c0 0f       	add	r28, r16
 694:	d1 1f       	adc	r29, r17
 696:	e0 91 72 07 	lds	r30, 0x0772
 69a:	f0 91 73 07 	lds	r31, 0x0773
 69e:	d3 83       	std	Z+3, r29	; 0x03
 6a0:	c2 83       	std	Z+2, r28	; 0x02
 6a2:	c0 17       	cp	r28, r16
 6a4:	d1 07       	cpc	r29, r17
 6a6:	60 f4       	brcc	.+24     	; 0x6c0 <prvAddCurrentTaskToDelayedList+0x70>
 6a8:	60 91 72 07 	lds	r22, 0x0772
 6ac:	70 91 73 07 	lds	r23, 0x0773
 6b0:	80 91 38 07 	lds	r24, 0x0738
 6b4:	90 91 39 07 	lds	r25, 0x0739
 6b8:	6e 5f       	subi	r22, 0xFE	; 254
 6ba:	7f 4f       	sbci	r23, 0xFF	; 255
 6bc:	fe dd       	rcall	.-1028   	; 0x2ba <vListInsert>
 6be:	16 c0       	rjmp	.+44     	; 0x6ec <prvAddCurrentTaskToDelayedList+0x9c>
 6c0:	60 91 72 07 	lds	r22, 0x0772
 6c4:	70 91 73 07 	lds	r23, 0x0773
 6c8:	80 91 3a 07 	lds	r24, 0x073A
 6cc:	90 91 3b 07 	lds	r25, 0x073B
 6d0:	6e 5f       	subi	r22, 0xFE	; 254
 6d2:	7f 4f       	sbci	r23, 0xFF	; 255
 6d4:	f2 dd       	rcall	.-1052   	; 0x2ba <vListInsert>
 6d6:	80 91 11 07 	lds	r24, 0x0711
 6da:	90 91 12 07 	lds	r25, 0x0712
 6de:	c8 17       	cp	r28, r24
 6e0:	d9 07       	cpc	r29, r25
 6e2:	20 f4       	brcc	.+8      	; 0x6ec <prvAddCurrentTaskToDelayedList+0x9c>
 6e4:	d0 93 12 07 	sts	0x0712, r29
 6e8:	c0 93 11 07 	sts	0x0711, r28
 6ec:	df 91       	pop	r29
 6ee:	cf 91       	pop	r28
 6f0:	1f 91       	pop	r17
 6f2:	0f 91       	pop	r16
 6f4:	ff 90       	pop	r15
 6f6:	08 95       	ret

000006f8 <xTaskCreate>:
 6f8:	4f 92       	push	r4
 6fa:	5f 92       	push	r5
 6fc:	6f 92       	push	r6
 6fe:	7f 92       	push	r7
 700:	8f 92       	push	r8
 702:	9f 92       	push	r9
 704:	af 92       	push	r10
 706:	bf 92       	push	r11
 708:	cf 92       	push	r12
 70a:	df 92       	push	r13
 70c:	ef 92       	push	r14
 70e:	ff 92       	push	r15
 710:	0f 93       	push	r16
 712:	cf 93       	push	r28
 714:	df 93       	push	r29
 716:	4c 01       	movw	r8, r24
 718:	6b 01       	movw	r12, r22
 71a:	5a 01       	movw	r10, r20
 71c:	29 01       	movw	r4, r18
 71e:	ca 01       	movw	r24, r20
 720:	65 dd       	rcall	.-1334   	; 0x1ec <pvPortMalloc>
 722:	3c 01       	movw	r6, r24
 724:	89 2b       	or	r24, r25
 726:	09 f4       	brne	.+2      	; 0x72a <xTaskCreate+0x32>
 728:	d2 c0       	rjmp	.+420    	; 0x8ce <xTaskCreate+0x1d6>
 72a:	8e e2       	ldi	r24, 0x2E	; 46
 72c:	90 e0       	ldi	r25, 0x00	; 0
 72e:	5e dd       	rcall	.-1348   	; 0x1ec <pvPortMalloc>
 730:	ec 01       	movw	r28, r24
 732:	89 2b       	or	r24, r25
 734:	71 f0       	breq	.+28     	; 0x752 <xTaskCreate+0x5a>
 736:	78 8e       	std	Y+24, r7	; 0x18
 738:	6f 8a       	std	Y+23, r6	; 0x17
 73a:	81 e0       	ldi	r24, 0x01	; 1
 73c:	a8 1a       	sub	r10, r24
 73e:	b1 08       	sbc	r11, r1
 740:	6a 0c       	add	r6, r10
 742:	7b 1c       	adc	r7, r11
 744:	d6 01       	movw	r26, r12
 746:	8c 91       	ld	r24, X
 748:	89 8f       	std	Y+25, r24	; 0x19
 74a:	8c 91       	ld	r24, X
 74c:	81 11       	cpse	r24, r1
 74e:	04 c0       	rjmp	.+8      	; 0x758 <xTaskCreate+0x60>
 750:	17 c0       	rjmp	.+46     	; 0x780 <xTaskCreate+0x88>
 752:	c3 01       	movw	r24, r6
 754:	7e dd       	rcall	.-1284   	; 0x252 <vPortFree>
 756:	bb c0       	rjmp	.+374    	; 0x8ce <xTaskCreate+0x1d6>
 758:	ae 01       	movw	r20, r28
 75a:	46 5e       	subi	r20, 0xE6	; 230
 75c:	5f 4f       	sbci	r21, 0xFF	; 255
 75e:	f6 01       	movw	r30, r12
 760:	31 96       	adiw	r30, 0x01	; 1
 762:	b0 e1       	ldi	r27, 0x10	; 16
 764:	cb 0e       	add	r12, r27
 766:	d1 1c       	adc	r13, r1
 768:	cf 01       	movw	r24, r30
 76a:	21 91       	ld	r18, Z+
 76c:	da 01       	movw	r26, r20
 76e:	2d 93       	st	X+, r18
 770:	ad 01       	movw	r20, r26
 772:	dc 01       	movw	r26, r24
 774:	8c 91       	ld	r24, X
 776:	88 23       	and	r24, r24
 778:	19 f0       	breq	.+6      	; 0x780 <xTaskCreate+0x88>
 77a:	ec 15       	cp	r30, r12
 77c:	fd 05       	cpc	r31, r13
 77e:	a1 f7       	brne	.-24     	; 0x768 <xTaskCreate+0x70>
 780:	18 a6       	std	Y+40, r1	; 0x28
 782:	04 30       	cpi	r16, 0x04	; 4
 784:	08 f0       	brcs	.+2      	; 0x788 <xTaskCreate+0x90>
 786:	03 e0       	ldi	r16, 0x03	; 3
 788:	0e 8b       	std	Y+22, r16	; 0x16
 78a:	6e 01       	movw	r12, r28
 78c:	b2 e0       	ldi	r27, 0x02	; 2
 78e:	cb 0e       	add	r12, r27
 790:	d1 1c       	adc	r13, r1
 792:	c6 01       	movw	r24, r12
 794:	6d dd       	rcall	.-1318   	; 0x270 <vListInitialiseItem>
 796:	ce 01       	movw	r24, r28
 798:	0c 96       	adiw	r24, 0x0c	; 12
 79a:	6a dd       	rcall	.-1324   	; 0x270 <vListInitialiseItem>
 79c:	d9 87       	std	Y+9, r29	; 0x09
 79e:	c8 87       	std	Y+8, r28	; 0x08
 7a0:	84 e0       	ldi	r24, 0x04	; 4
 7a2:	90 e0       	ldi	r25, 0x00	; 0
 7a4:	80 1b       	sub	r24, r16
 7a6:	91 09       	sbc	r25, r1
 7a8:	9d 87       	std	Y+13, r25	; 0x0d
 7aa:	8c 87       	std	Y+12, r24	; 0x0c
 7ac:	db 8b       	std	Y+19, r29	; 0x13
 7ae:	ca 8b       	std	Y+18, r28	; 0x12
 7b0:	19 a6       	std	Y+41, r1	; 0x29
 7b2:	1a a6       	std	Y+42, r1	; 0x2a
 7b4:	1b a6       	std	Y+43, r1	; 0x2b
 7b6:	1c a6       	std	Y+44, r1	; 0x2c
 7b8:	1d a6       	std	Y+45, r1	; 0x2d
 7ba:	a2 01       	movw	r20, r4
 7bc:	b4 01       	movw	r22, r8
 7be:	c3 01       	movw	r24, r6
 7c0:	d3 dd       	rcall	.-1114   	; 0x368 <pxPortInitialiseStack>
 7c2:	99 83       	std	Y+1, r25	; 0x01
 7c4:	88 83       	st	Y, r24
 7c6:	e1 14       	cp	r14, r1
 7c8:	f1 04       	cpc	r15, r1
 7ca:	19 f0       	breq	.+6      	; 0x7d2 <xTaskCreate+0xda>
 7cc:	f7 01       	movw	r30, r14
 7ce:	d1 83       	std	Z+1, r29	; 0x01
 7d0:	c0 83       	st	Z, r28
 7d2:	0f b6       	in	r0, 0x3f	; 63
 7d4:	f8 94       	cli
 7d6:	0f 92       	push	r0
 7d8:	80 91 1b 07 	lds	r24, 0x071B
 7dc:	8f 5f       	subi	r24, 0xFF	; 255
 7de:	80 93 1b 07 	sts	0x071B, r24
 7e2:	80 91 72 07 	lds	r24, 0x0772
 7e6:	90 91 73 07 	lds	r25, 0x0773
 7ea:	89 2b       	or	r24, r25
 7ec:	89 f5       	brne	.+98     	; 0x850 <xTaskCreate+0x158>
 7ee:	d0 93 73 07 	sts	0x0773, r29
 7f2:	c0 93 72 07 	sts	0x0772, r28
 7f6:	80 91 1b 07 	lds	r24, 0x071B
 7fa:	81 30       	cpi	r24, 0x01	; 1
 7fc:	09 f0       	breq	.+2      	; 0x800 <xTaskCreate+0x108>
 7fe:	38 c0       	rjmp	.+112    	; 0x870 <xTaskCreate+0x178>
 800:	8e e4       	ldi	r24, 0x4E	; 78
 802:	97 e0       	ldi	r25, 0x07	; 7
 804:	27 dd       	rcall	.-1458   	; 0x254 <vListInitialise>
 806:	87 e5       	ldi	r24, 0x57	; 87
 808:	97 e0       	ldi	r25, 0x07	; 7
 80a:	24 dd       	rcall	.-1464   	; 0x254 <vListInitialise>
 80c:	80 e6       	ldi	r24, 0x60	; 96
 80e:	97 e0       	ldi	r25, 0x07	; 7
 810:	21 dd       	rcall	.-1470   	; 0x254 <vListInitialise>
 812:	89 e6       	ldi	r24, 0x69	; 105
 814:	97 e0       	ldi	r25, 0x07	; 7
 816:	1e dd       	rcall	.-1476   	; 0x254 <vListInitialise>
 818:	85 e4       	ldi	r24, 0x45	; 69
 81a:	97 e0       	ldi	r25, 0x07	; 7
 81c:	1b dd       	rcall	.-1482   	; 0x254 <vListInitialise>
 81e:	8c e3       	ldi	r24, 0x3C	; 60
 820:	97 e0       	ldi	r25, 0x07	; 7
 822:	18 dd       	rcall	.-1488   	; 0x254 <vListInitialise>
 824:	8f e2       	ldi	r24, 0x2F	; 47
 826:	97 e0       	ldi	r25, 0x07	; 7
 828:	15 dd       	rcall	.-1494   	; 0x254 <vListInitialise>
 82a:	86 e2       	ldi	r24, 0x26	; 38
 82c:	97 e0       	ldi	r25, 0x07	; 7
 82e:	12 dd       	rcall	.-1500   	; 0x254 <vListInitialise>
 830:	8c e1       	ldi	r24, 0x1C	; 28
 832:	97 e0       	ldi	r25, 0x07	; 7
 834:	0f dd       	rcall	.-1506   	; 0x254 <vListInitialise>
 836:	85 e4       	ldi	r24, 0x45	; 69
 838:	97 e0       	ldi	r25, 0x07	; 7
 83a:	90 93 3b 07 	sts	0x073B, r25
 83e:	80 93 3a 07 	sts	0x073A, r24
 842:	8c e3       	ldi	r24, 0x3C	; 60
 844:	97 e0       	ldi	r25, 0x07	; 7
 846:	90 93 39 07 	sts	0x0739, r25
 84a:	80 93 38 07 	sts	0x0738, r24
 84e:	10 c0       	rjmp	.+32     	; 0x870 <xTaskCreate+0x178>
 850:	80 91 17 07 	lds	r24, 0x0717
 854:	81 11       	cpse	r24, r1
 856:	0c c0       	rjmp	.+24     	; 0x870 <xTaskCreate+0x178>
 858:	e0 91 72 07 	lds	r30, 0x0772
 85c:	f0 91 73 07 	lds	r31, 0x0773
 860:	96 89       	ldd	r25, Z+22	; 0x16
 862:	8e 89       	ldd	r24, Y+22	; 0x16
 864:	89 17       	cp	r24, r25
 866:	20 f0       	brcs	.+8      	; 0x870 <xTaskCreate+0x178>
 868:	d0 93 73 07 	sts	0x0773, r29
 86c:	c0 93 72 07 	sts	0x0772, r28
 870:	80 91 13 07 	lds	r24, 0x0713
 874:	8f 5f       	subi	r24, 0xFF	; 255
 876:	80 93 13 07 	sts	0x0713, r24
 87a:	8e 89       	ldd	r24, Y+22	; 0x16
 87c:	90 91 18 07 	lds	r25, 0x0718
 880:	98 17       	cp	r25, r24
 882:	10 f4       	brcc	.+4      	; 0x888 <xTaskCreate+0x190>
 884:	80 93 18 07 	sts	0x0718, r24
 888:	90 e0       	ldi	r25, 0x00	; 0
 88a:	9c 01       	movw	r18, r24
 88c:	22 0f       	add	r18, r18
 88e:	33 1f       	adc	r19, r19
 890:	22 0f       	add	r18, r18
 892:	33 1f       	adc	r19, r19
 894:	22 0f       	add	r18, r18
 896:	33 1f       	adc	r19, r19
 898:	82 0f       	add	r24, r18
 89a:	93 1f       	adc	r25, r19
 89c:	b6 01       	movw	r22, r12
 89e:	82 5b       	subi	r24, 0xB2	; 178
 8a0:	98 4f       	sbci	r25, 0xF8	; 248
 8a2:	ea dc       	rcall	.-1580   	; 0x278 <vListInsertEnd>
 8a4:	0f 90       	pop	r0
 8a6:	0f be       	out	0x3f, r0	; 63
 8a8:	80 91 17 07 	lds	r24, 0x0717
 8ac:	88 23       	and	r24, r24
 8ae:	59 f0       	breq	.+22     	; 0x8c6 <xTaskCreate+0x1ce>
 8b0:	e0 91 72 07 	lds	r30, 0x0772
 8b4:	f0 91 73 07 	lds	r31, 0x0773
 8b8:	96 89       	ldd	r25, Z+22	; 0x16
 8ba:	8e 89       	ldd	r24, Y+22	; 0x16
 8bc:	98 17       	cp	r25, r24
 8be:	28 f4       	brcc	.+10     	; 0x8ca <xTaskCreate+0x1d2>
 8c0:	f4 dd       	rcall	.-1048   	; 0x4aa <vPortYield>
 8c2:	81 e0       	ldi	r24, 0x01	; 1
 8c4:	05 c0       	rjmp	.+10     	; 0x8d0 <xTaskCreate+0x1d8>
 8c6:	81 e0       	ldi	r24, 0x01	; 1
 8c8:	03 c0       	rjmp	.+6      	; 0x8d0 <xTaskCreate+0x1d8>
 8ca:	81 e0       	ldi	r24, 0x01	; 1
 8cc:	01 c0       	rjmp	.+2      	; 0x8d0 <xTaskCreate+0x1d8>
 8ce:	8f ef       	ldi	r24, 0xFF	; 255
 8d0:	df 91       	pop	r29
 8d2:	cf 91       	pop	r28
 8d4:	0f 91       	pop	r16
 8d6:	ff 90       	pop	r15
 8d8:	ef 90       	pop	r14
 8da:	df 90       	pop	r13
 8dc:	cf 90       	pop	r12
 8de:	bf 90       	pop	r11
 8e0:	af 90       	pop	r10
 8e2:	9f 90       	pop	r9
 8e4:	8f 90       	pop	r8
 8e6:	7f 90       	pop	r7
 8e8:	6f 90       	pop	r6
 8ea:	5f 90       	pop	r5
 8ec:	4f 90       	pop	r4
 8ee:	08 95       	ret

000008f0 <vTaskStartScheduler>:
 8f0:	ef 92       	push	r14
 8f2:	ff 92       	push	r15
 8f4:	0f 93       	push	r16
 8f6:	0f 2e       	mov	r0, r31
 8f8:	ff e0       	ldi	r31, 0x0F	; 15
 8fa:	ef 2e       	mov	r14, r31
 8fc:	f7 e0       	ldi	r31, 0x07	; 7
 8fe:	ff 2e       	mov	r15, r31
 900:	f0 2d       	mov	r31, r0
 902:	00 e0       	ldi	r16, 0x00	; 0
 904:	20 e0       	ldi	r18, 0x00	; 0
 906:	30 e0       	ldi	r19, 0x00	; 0
 908:	45 e5       	ldi	r20, 0x55	; 85
 90a:	50 e0       	ldi	r21, 0x00	; 0
 90c:	68 e2       	ldi	r22, 0x28	; 40
 90e:	71 e0       	ldi	r23, 0x01	; 1
 910:	8c e1       	ldi	r24, 0x1C	; 28
 912:	96 e0       	ldi	r25, 0x06	; 6
 914:	f1 de       	rcall	.-542    	; 0x6f8 <xTaskCreate>
 916:	81 30       	cpi	r24, 0x01	; 1
 918:	79 f4       	brne	.+30     	; 0x938 <vTaskStartScheduler+0x48>
 91a:	f8 94       	cli
 91c:	8f ef       	ldi	r24, 0xFF	; 255
 91e:	9f ef       	ldi	r25, 0xFF	; 255
 920:	90 93 12 07 	sts	0x0712, r25
 924:	80 93 11 07 	sts	0x0711, r24
 928:	81 e0       	ldi	r24, 0x01	; 1
 92a:	80 93 17 07 	sts	0x0717, r24
 92e:	10 92 1a 07 	sts	0x071A, r1
 932:	10 92 19 07 	sts	0x0719, r1
 936:	84 dd       	rcall	.-1272   	; 0x440 <xPortStartScheduler>
 938:	0f 91       	pop	r16
 93a:	ff 90       	pop	r15
 93c:	ef 90       	pop	r14
 93e:	08 95       	ret

00000940 <vTaskSuspendAll>:
 940:	80 91 0e 07 	lds	r24, 0x070E
 944:	8f 5f       	subi	r24, 0xFF	; 255
 946:	80 93 0e 07 	sts	0x070E, r24
 94a:	08 95       	ret

0000094c <xTaskGetTickCount>:
 94c:	0f b6       	in	r0, 0x3f	; 63
 94e:	f8 94       	cli
 950:	0f 92       	push	r0
 952:	80 91 19 07 	lds	r24, 0x0719
 956:	90 91 1a 07 	lds	r25, 0x071A
 95a:	0f 90       	pop	r0
 95c:	0f be       	out	0x3f, r0	; 63
 95e:	08 95       	ret

00000960 <xTaskIncrementTick>:
 960:	cf 92       	push	r12
 962:	df 92       	push	r13
 964:	ef 92       	push	r14
 966:	ff 92       	push	r15
 968:	0f 93       	push	r16
 96a:	1f 93       	push	r17
 96c:	cf 93       	push	r28
 96e:	df 93       	push	r29
 970:	80 91 0e 07 	lds	r24, 0x070E
 974:	81 11       	cpse	r24, r1
 976:	95 c0       	rjmp	.+298    	; 0xaa2 <xTaskIncrementTick+0x142>
 978:	e0 90 19 07 	lds	r14, 0x0719
 97c:	f0 90 1a 07 	lds	r15, 0x071A
 980:	8f ef       	ldi	r24, 0xFF	; 255
 982:	e8 1a       	sub	r14, r24
 984:	f8 0a       	sbc	r15, r24
 986:	f0 92 1a 07 	sts	0x071A, r15
 98a:	e0 92 19 07 	sts	0x0719, r14
 98e:	e1 14       	cp	r14, r1
 990:	f1 04       	cpc	r15, r1
 992:	b1 f4       	brne	.+44     	; 0x9c0 <xTaskIncrementTick+0x60>
 994:	80 91 3a 07 	lds	r24, 0x073A
 998:	90 91 3b 07 	lds	r25, 0x073B
 99c:	20 91 38 07 	lds	r18, 0x0738
 9a0:	30 91 39 07 	lds	r19, 0x0739
 9a4:	30 93 3b 07 	sts	0x073B, r19
 9a8:	20 93 3a 07 	sts	0x073A, r18
 9ac:	90 93 39 07 	sts	0x0739, r25
 9b0:	80 93 38 07 	sts	0x0738, r24
 9b4:	80 91 14 07 	lds	r24, 0x0714
 9b8:	8f 5f       	subi	r24, 0xFF	; 255
 9ba:	80 93 14 07 	sts	0x0714, r24
 9be:	29 de       	rcall	.-942    	; 0x612 <prvResetNextTaskUnblockTime>
 9c0:	80 91 11 07 	lds	r24, 0x0711
 9c4:	90 91 12 07 	lds	r25, 0x0712
 9c8:	e8 16       	cp	r14, r24
 9ca:	f9 06       	cpc	r15, r25
 9cc:	10 f4       	brcc	.+4      	; 0x9d2 <xTaskIncrementTick+0x72>
 9ce:	d1 2c       	mov	r13, r1
 9d0:	50 c0       	rjmp	.+160    	; 0xa72 <xTaskIncrementTick+0x112>
 9d2:	d1 2c       	mov	r13, r1
 9d4:	cc 24       	eor	r12, r12
 9d6:	c3 94       	inc	r12
 9d8:	e0 91 3a 07 	lds	r30, 0x073A
 9dc:	f0 91 3b 07 	lds	r31, 0x073B
 9e0:	90 81       	ld	r25, Z
 9e2:	91 11       	cpse	r25, r1
 9e4:	07 c0       	rjmp	.+14     	; 0x9f4 <xTaskIncrementTick+0x94>
 9e6:	8f ef       	ldi	r24, 0xFF	; 255
 9e8:	9f ef       	ldi	r25, 0xFF	; 255
 9ea:	90 93 12 07 	sts	0x0712, r25
 9ee:	80 93 11 07 	sts	0x0711, r24
 9f2:	3f c0       	rjmp	.+126    	; 0xa72 <xTaskIncrementTick+0x112>
 9f4:	e0 91 3a 07 	lds	r30, 0x073A
 9f8:	f0 91 3b 07 	lds	r31, 0x073B
 9fc:	05 80       	ldd	r0, Z+5	; 0x05
 9fe:	f6 81       	ldd	r31, Z+6	; 0x06
 a00:	e0 2d       	mov	r30, r0
 a02:	c6 81       	ldd	r28, Z+6	; 0x06
 a04:	d7 81       	ldd	r29, Z+7	; 0x07
 a06:	2a 81       	ldd	r18, Y+2	; 0x02
 a08:	3b 81       	ldd	r19, Y+3	; 0x03
 a0a:	e2 16       	cp	r14, r18
 a0c:	f3 06       	cpc	r15, r19
 a0e:	28 f4       	brcc	.+10     	; 0xa1a <xTaskIncrementTick+0xba>
 a10:	30 93 12 07 	sts	0x0712, r19
 a14:	20 93 11 07 	sts	0x0711, r18
 a18:	2c c0       	rjmp	.+88     	; 0xa72 <xTaskIncrementTick+0x112>
 a1a:	8e 01       	movw	r16, r28
 a1c:	0e 5f       	subi	r16, 0xFE	; 254
 a1e:	1f 4f       	sbci	r17, 0xFF	; 255
 a20:	c8 01       	movw	r24, r16
 a22:	7c dc       	rcall	.-1800   	; 0x31c <uxListRemove>
 a24:	8c 89       	ldd	r24, Y+20	; 0x14
 a26:	9d 89       	ldd	r25, Y+21	; 0x15
 a28:	89 2b       	or	r24, r25
 a2a:	19 f0       	breq	.+6      	; 0xa32 <xTaskIncrementTick+0xd2>
 a2c:	ce 01       	movw	r24, r28
 a2e:	0c 96       	adiw	r24, 0x0c	; 12
 a30:	75 dc       	rcall	.-1814   	; 0x31c <uxListRemove>
 a32:	2e 89       	ldd	r18, Y+22	; 0x16
 a34:	80 91 18 07 	lds	r24, 0x0718
 a38:	82 17       	cp	r24, r18
 a3a:	10 f4       	brcc	.+4      	; 0xa40 <xTaskIncrementTick+0xe0>
 a3c:	20 93 18 07 	sts	0x0718, r18
 a40:	30 e0       	ldi	r19, 0x00	; 0
 a42:	c9 01       	movw	r24, r18
 a44:	88 0f       	add	r24, r24
 a46:	99 1f       	adc	r25, r25
 a48:	88 0f       	add	r24, r24
 a4a:	99 1f       	adc	r25, r25
 a4c:	88 0f       	add	r24, r24
 a4e:	99 1f       	adc	r25, r25
 a50:	82 0f       	add	r24, r18
 a52:	93 1f       	adc	r25, r19
 a54:	b8 01       	movw	r22, r16
 a56:	82 5b       	subi	r24, 0xB2	; 178
 a58:	98 4f       	sbci	r25, 0xF8	; 248
 a5a:	0e dc       	rcall	.-2020   	; 0x278 <vListInsertEnd>
 a5c:	e0 91 72 07 	lds	r30, 0x0772
 a60:	f0 91 73 07 	lds	r31, 0x0773
 a64:	9e 89       	ldd	r25, Y+22	; 0x16
 a66:	86 89       	ldd	r24, Z+22	; 0x16
 a68:	98 17       	cp	r25, r24
 a6a:	08 f4       	brcc	.+2      	; 0xa6e <xTaskIncrementTick+0x10e>
 a6c:	b5 cf       	rjmp	.-150    	; 0x9d8 <xTaskIncrementTick+0x78>
 a6e:	dc 2c       	mov	r13, r12
 a70:	b3 cf       	rjmp	.-154    	; 0x9d8 <xTaskIncrementTick+0x78>
 a72:	e0 91 72 07 	lds	r30, 0x0772
 a76:	f0 91 73 07 	lds	r31, 0x0773
 a7a:	86 89       	ldd	r24, Z+22	; 0x16
 a7c:	90 e0       	ldi	r25, 0x00	; 0
 a7e:	fc 01       	movw	r30, r24
 a80:	ee 0f       	add	r30, r30
 a82:	ff 1f       	adc	r31, r31
 a84:	ee 0f       	add	r30, r30
 a86:	ff 1f       	adc	r31, r31
 a88:	ee 0f       	add	r30, r30
 a8a:	ff 1f       	adc	r31, r31
 a8c:	8e 0f       	add	r24, r30
 a8e:	9f 1f       	adc	r25, r31
 a90:	fc 01       	movw	r30, r24
 a92:	e2 5b       	subi	r30, 0xB2	; 178
 a94:	f8 4f       	sbci	r31, 0xF8	; 248
 a96:	80 81       	ld	r24, Z
 a98:	82 30       	cpi	r24, 0x02	; 2
 a9a:	48 f0       	brcs	.+18     	; 0xaae <xTaskIncrementTick+0x14e>
 a9c:	dd 24       	eor	r13, r13
 a9e:	d3 94       	inc	r13
 aa0:	06 c0       	rjmp	.+12     	; 0xaae <xTaskIncrementTick+0x14e>
 aa2:	80 91 16 07 	lds	r24, 0x0716
 aa6:	8f 5f       	subi	r24, 0xFF	; 255
 aa8:	80 93 16 07 	sts	0x0716, r24
 aac:	d1 2c       	mov	r13, r1
 aae:	80 91 15 07 	lds	r24, 0x0715
 ab2:	88 23       	and	r24, r24
 ab4:	11 f0       	breq	.+4      	; 0xaba <xTaskIncrementTick+0x15a>
 ab6:	dd 24       	eor	r13, r13
 ab8:	d3 94       	inc	r13
 aba:	8d 2d       	mov	r24, r13
 abc:	df 91       	pop	r29
 abe:	cf 91       	pop	r28
 ac0:	1f 91       	pop	r17
 ac2:	0f 91       	pop	r16
 ac4:	ff 90       	pop	r15
 ac6:	ef 90       	pop	r14
 ac8:	df 90       	pop	r13
 aca:	cf 90       	pop	r12
 acc:	08 95       	ret

00000ace <xTaskResumeAll>:
 ace:	df 92       	push	r13
 ad0:	ef 92       	push	r14
 ad2:	ff 92       	push	r15
 ad4:	0f 93       	push	r16
 ad6:	1f 93       	push	r17
 ad8:	cf 93       	push	r28
 ada:	df 93       	push	r29
 adc:	0f b6       	in	r0, 0x3f	; 63
 ade:	f8 94       	cli
 ae0:	0f 92       	push	r0
 ae2:	80 91 0e 07 	lds	r24, 0x070E
 ae6:	81 50       	subi	r24, 0x01	; 1
 ae8:	80 93 0e 07 	sts	0x070E, r24
 aec:	80 91 0e 07 	lds	r24, 0x070E
 af0:	81 11       	cpse	r24, r1
 af2:	59 c0       	rjmp	.+178    	; 0xba6 <xTaskResumeAll+0xd8>
 af4:	80 91 1b 07 	lds	r24, 0x071B
 af8:	81 11       	cpse	r24, r1
 afa:	30 c0       	rjmp	.+96     	; 0xb5c <xTaskResumeAll+0x8e>
 afc:	57 c0       	rjmp	.+174    	; 0xbac <xTaskResumeAll+0xde>
 afe:	d7 01       	movw	r26, r14
 b00:	15 96       	adiw	r26, 0x05	; 5
 b02:	ed 91       	ld	r30, X+
 b04:	fc 91       	ld	r31, X
 b06:	16 97       	sbiw	r26, 0x06	; 6
 b08:	c6 81       	ldd	r28, Z+6	; 0x06
 b0a:	d7 81       	ldd	r29, Z+7	; 0x07
 b0c:	ce 01       	movw	r24, r28
 b0e:	0c 96       	adiw	r24, 0x0c	; 12
 b10:	05 dc       	rcall	.-2038   	; 0x31c <uxListRemove>
 b12:	8e 01       	movw	r16, r28
 b14:	0e 5f       	subi	r16, 0xFE	; 254
 b16:	1f 4f       	sbci	r17, 0xFF	; 255
 b18:	c8 01       	movw	r24, r16
 b1a:	00 dc       	rcall	.-2048   	; 0x31c <uxListRemove>
 b1c:	2e 89       	ldd	r18, Y+22	; 0x16
 b1e:	80 91 18 07 	lds	r24, 0x0718
 b22:	82 17       	cp	r24, r18
 b24:	10 f4       	brcc	.+4      	; 0xb2a <xTaskResumeAll+0x5c>
 b26:	20 93 18 07 	sts	0x0718, r18
 b2a:	30 e0       	ldi	r19, 0x00	; 0
 b2c:	c9 01       	movw	r24, r18
 b2e:	88 0f       	add	r24, r24
 b30:	99 1f       	adc	r25, r25
 b32:	88 0f       	add	r24, r24
 b34:	99 1f       	adc	r25, r25
 b36:	88 0f       	add	r24, r24
 b38:	99 1f       	adc	r25, r25
 b3a:	82 0f       	add	r24, r18
 b3c:	93 1f       	adc	r25, r19
 b3e:	b8 01       	movw	r22, r16
 b40:	82 5b       	subi	r24, 0xB2	; 178
 b42:	98 4f       	sbci	r25, 0xF8	; 248
 b44:	99 db       	rcall	.-2254   	; 0x278 <vListInsertEnd>
 b46:	e0 91 72 07 	lds	r30, 0x0772
 b4a:	f0 91 73 07 	lds	r31, 0x0773
 b4e:	9e 89       	ldd	r25, Y+22	; 0x16
 b50:	86 89       	ldd	r24, Z+22	; 0x16
 b52:	98 17       	cp	r25, r24
 b54:	68 f0       	brcs	.+26     	; 0xb70 <xTaskResumeAll+0xa2>
 b56:	d0 92 15 07 	sts	0x0715, r13
 b5a:	0a c0       	rjmp	.+20     	; 0xb70 <xTaskResumeAll+0xa2>
 b5c:	c0 e0       	ldi	r28, 0x00	; 0
 b5e:	d0 e0       	ldi	r29, 0x00	; 0
 b60:	0f 2e       	mov	r0, r31
 b62:	ff e2       	ldi	r31, 0x2F	; 47
 b64:	ef 2e       	mov	r14, r31
 b66:	f7 e0       	ldi	r31, 0x07	; 7
 b68:	ff 2e       	mov	r15, r31
 b6a:	f0 2d       	mov	r31, r0
 b6c:	dd 24       	eor	r13, r13
 b6e:	d3 94       	inc	r13
 b70:	f7 01       	movw	r30, r14
 b72:	80 81       	ld	r24, Z
 b74:	81 11       	cpse	r24, r1
 b76:	c3 cf       	rjmp	.-122    	; 0xafe <xTaskResumeAll+0x30>
 b78:	cd 2b       	or	r28, r29
 b7a:	09 f0       	breq	.+2      	; 0xb7e <xTaskResumeAll+0xb0>
 b7c:	4a dd       	rcall	.-1388   	; 0x612 <prvResetNextTaskUnblockTime>
 b7e:	c0 91 16 07 	lds	r28, 0x0716
 b82:	cc 23       	and	r28, r28
 b84:	49 f0       	breq	.+18     	; 0xb98 <xTaskResumeAll+0xca>
 b86:	d1 e0       	ldi	r29, 0x01	; 1
 b88:	eb de       	rcall	.-554    	; 0x960 <xTaskIncrementTick>
 b8a:	81 11       	cpse	r24, r1
 b8c:	d0 93 15 07 	sts	0x0715, r29
 b90:	c1 50       	subi	r28, 0x01	; 1
 b92:	d1 f7       	brne	.-12     	; 0xb88 <xTaskResumeAll+0xba>
 b94:	10 92 16 07 	sts	0x0716, r1
 b98:	80 91 15 07 	lds	r24, 0x0715
 b9c:	88 23       	and	r24, r24
 b9e:	29 f0       	breq	.+10     	; 0xbaa <xTaskResumeAll+0xdc>
 ba0:	84 dc       	rcall	.-1784   	; 0x4aa <vPortYield>
 ba2:	81 e0       	ldi	r24, 0x01	; 1
 ba4:	03 c0       	rjmp	.+6      	; 0xbac <xTaskResumeAll+0xde>
 ba6:	80 e0       	ldi	r24, 0x00	; 0
 ba8:	01 c0       	rjmp	.+2      	; 0xbac <xTaskResumeAll+0xde>
 baa:	80 e0       	ldi	r24, 0x00	; 0
 bac:	0f 90       	pop	r0
 bae:	0f be       	out	0x3f, r0	; 63
 bb0:	df 91       	pop	r29
 bb2:	cf 91       	pop	r28
 bb4:	1f 91       	pop	r17
 bb6:	0f 91       	pop	r16
 bb8:	ff 90       	pop	r15
 bba:	ef 90       	pop	r14
 bbc:	df 90       	pop	r13
 bbe:	08 95       	ret

00000bc0 <vTaskDelayUntil>:
 bc0:	0f 93       	push	r16
 bc2:	1f 93       	push	r17
 bc4:	cf 93       	push	r28
 bc6:	df 93       	push	r29
 bc8:	8c 01       	movw	r16, r24
 bca:	eb 01       	movw	r28, r22
 bcc:	b9 de       	rcall	.-654    	; 0x940 <vTaskSuspendAll>
 bce:	80 91 19 07 	lds	r24, 0x0719
 bd2:	90 91 1a 07 	lds	r25, 0x071A
 bd6:	f8 01       	movw	r30, r16
 bd8:	40 81       	ld	r20, Z
 bda:	51 81       	ldd	r21, Z+1	; 0x01
 bdc:	9a 01       	movw	r18, r20
 bde:	2c 0f       	add	r18, r28
 be0:	3d 1f       	adc	r19, r29
 be2:	84 17       	cp	r24, r20
 be4:	95 07       	cpc	r25, r21
 be6:	48 f4       	brcc	.+18     	; 0xbfa <vTaskDelayUntil+0x3a>
 be8:	24 17       	cp	r18, r20
 bea:	35 07       	cpc	r19, r21
 bec:	e0 f4       	brcc	.+56     	; 0xc26 <vTaskDelayUntil+0x66>
 bee:	31 83       	std	Z+1, r19	; 0x01
 bf0:	20 83       	st	Z, r18
 bf2:	82 17       	cp	r24, r18
 bf4:	93 07       	cpc	r25, r19
 bf6:	70 f4       	brcc	.+28     	; 0xc14 <vTaskDelayUntil+0x54>
 bf8:	07 c0       	rjmp	.+14     	; 0xc08 <vTaskDelayUntil+0x48>
 bfa:	24 17       	cp	r18, r20
 bfc:	35 07       	cpc	r19, r21
 bfe:	78 f0       	brcs	.+30     	; 0xc1e <vTaskDelayUntil+0x5e>
 c00:	82 17       	cp	r24, r18
 c02:	93 07       	cpc	r25, r19
 c04:	60 f0       	brcs	.+24     	; 0xc1e <vTaskDelayUntil+0x5e>
 c06:	0f c0       	rjmp	.+30     	; 0xc26 <vTaskDelayUntil+0x66>
 c08:	60 e0       	ldi	r22, 0x00	; 0
 c0a:	a9 01       	movw	r20, r18
 c0c:	48 1b       	sub	r20, r24
 c0e:	59 0b       	sbc	r21, r25
 c10:	ca 01       	movw	r24, r20
 c12:	1e dd       	rcall	.-1476   	; 0x650 <prvAddCurrentTaskToDelayedList>
 c14:	5c df       	rcall	.-328    	; 0xace <xTaskResumeAll>
 c16:	81 11       	cpse	r24, r1
 c18:	0a c0       	rjmp	.+20     	; 0xc2e <vTaskDelayUntil+0x6e>
 c1a:	47 dc       	rcall	.-1906   	; 0x4aa <vPortYield>
 c1c:	08 c0       	rjmp	.+16     	; 0xc2e <vTaskDelayUntil+0x6e>
 c1e:	f8 01       	movw	r30, r16
 c20:	31 83       	std	Z+1, r19	; 0x01
 c22:	20 83       	st	Z, r18
 c24:	f1 cf       	rjmp	.-30     	; 0xc08 <vTaskDelayUntil+0x48>
 c26:	f8 01       	movw	r30, r16
 c28:	31 83       	std	Z+1, r19	; 0x01
 c2a:	20 83       	st	Z, r18
 c2c:	f3 cf       	rjmp	.-26     	; 0xc14 <vTaskDelayUntil+0x54>
 c2e:	df 91       	pop	r29
 c30:	cf 91       	pop	r28
 c32:	1f 91       	pop	r17
 c34:	0f 91       	pop	r16
 c36:	08 95       	ret

00000c38 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c38:	06 e2       	ldi	r16, 0x26	; 38
 c3a:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 c3c:	0f 2e       	mov	r0, r31
 c3e:	fe e4       	ldi	r31, 0x4E	; 78
 c40:	ef 2e       	mov	r14, r31
 c42:	f7 e0       	ldi	r31, 0x07	; 7
 c44:	ff 2e       	mov	r15, r31
 c46:	f0 2d       	mov	r31, r0
 c48:	24 c0       	rjmp	.+72     	; 0xc92 <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 c4a:	7a de       	rcall	.-780    	; 0x940 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c4c:	d8 01       	movw	r26, r16
 c4e:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 c50:	3e df       	rcall	.-388    	; 0xace <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 c52:	cc 23       	and	r28, r28
 c54:	f1 f0       	breq	.+60     	; 0xc92 <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 c56:	0f b6       	in	r0, 0x3f	; 63
 c58:	f8 94       	cli
 c5a:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 c5c:	d8 01       	movw	r26, r16
 c5e:	15 96       	adiw	r26, 0x05	; 5
 c60:	ed 91       	ld	r30, X+
 c62:	fc 91       	ld	r31, X
 c64:	16 97       	sbiw	r26, 0x06	; 6
 c66:	c6 81       	ldd	r28, Z+6	; 0x06
 c68:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 c6a:	ce 01       	movw	r24, r28
 c6c:	02 96       	adiw	r24, 0x02	; 2
 c6e:	56 db       	rcall	.-2388   	; 0x31c <uxListRemove>
					--uxCurrentNumberOfTasks;
 c70:	80 91 1b 07 	lds	r24, 0x071B
 c74:	81 50       	subi	r24, 0x01	; 1
 c76:	80 93 1b 07 	sts	0x071B, r24
					--uxDeletedTasksWaitingCleanUp;
 c7a:	80 91 25 07 	lds	r24, 0x0725
 c7e:	81 50       	subi	r24, 0x01	; 1
 c80:	80 93 25 07 	sts	0x0725, r24
				}
				taskEXIT_CRITICAL();
 c84:	0f 90       	pop	r0
 c86:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 c88:	8f 89       	ldd	r24, Y+23	; 0x17
 c8a:	98 8d       	ldd	r25, Y+24	; 0x18
 c8c:	e2 da       	rcall	.-2620   	; 0x252 <vPortFree>
			vPortFree( pxTCB );
 c8e:	ce 01       	movw	r24, r28
 c90:	e0 da       	rcall	.-2624   	; 0x252 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 c92:	80 91 25 07 	lds	r24, 0x0725
 c96:	81 11       	cpse	r24, r1
 c98:	d8 cf       	rjmp	.-80     	; 0xc4a <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 c9a:	f7 01       	movw	r30, r14
 c9c:	80 81       	ld	r24, Z
 c9e:	82 30       	cpi	r24, 0x02	; 2
 ca0:	c0 f3       	brcs	.-16     	; 0xc92 <prvIdleTask+0x5a>
			{
				taskYIELD();
 ca2:	03 dc       	rcall	.-2042   	; 0x4aa <vPortYield>
 ca4:	f6 cf       	rjmp	.-20     	; 0xc92 <prvIdleTask+0x5a>

00000ca6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 ca6:	80 91 0e 07 	lds	r24, 0x070E
 caa:	88 23       	and	r24, r24
 cac:	21 f0       	breq	.+8      	; 0xcb6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 cae:	81 e0       	ldi	r24, 0x01	; 1
 cb0:	80 93 15 07 	sts	0x0715, r24
 cb4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 cb6:	10 92 15 07 	sts	0x0715, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 cba:	20 91 18 07 	lds	r18, 0x0718
 cbe:	82 2f       	mov	r24, r18
 cc0:	90 e0       	ldi	r25, 0x00	; 0
 cc2:	fc 01       	movw	r30, r24
 cc4:	ee 0f       	add	r30, r30
 cc6:	ff 1f       	adc	r31, r31
 cc8:	ee 0f       	add	r30, r30
 cca:	ff 1f       	adc	r31, r31
 ccc:	ee 0f       	add	r30, r30
 cce:	ff 1f       	adc	r31, r31
 cd0:	e8 0f       	add	r30, r24
 cd2:	f9 1f       	adc	r31, r25
 cd4:	e2 5b       	subi	r30, 0xB2	; 178
 cd6:	f8 4f       	sbci	r31, 0xF8	; 248
 cd8:	30 81       	ld	r19, Z
 cda:	31 11       	cpse	r19, r1
 cdc:	11 c0       	rjmp	.+34     	; 0xd00 <vTaskSwitchContext+0x5a>
 cde:	21 50       	subi	r18, 0x01	; 1
 ce0:	82 2f       	mov	r24, r18
 ce2:	90 e0       	ldi	r25, 0x00	; 0
 ce4:	fc 01       	movw	r30, r24
 ce6:	ee 0f       	add	r30, r30
 ce8:	ff 1f       	adc	r31, r31
 cea:	ee 0f       	add	r30, r30
 cec:	ff 1f       	adc	r31, r31
 cee:	ee 0f       	add	r30, r30
 cf0:	ff 1f       	adc	r31, r31
 cf2:	e8 0f       	add	r30, r24
 cf4:	f9 1f       	adc	r31, r25
 cf6:	e2 5b       	subi	r30, 0xB2	; 178
 cf8:	f8 4f       	sbci	r31, 0xF8	; 248
 cfa:	30 81       	ld	r19, Z
 cfc:	33 23       	and	r19, r19
 cfe:	79 f3       	breq	.-34     	; 0xcde <vTaskSwitchContext+0x38>
 d00:	ac 01       	movw	r20, r24
 d02:	44 0f       	add	r20, r20
 d04:	55 1f       	adc	r21, r21
 d06:	44 0f       	add	r20, r20
 d08:	55 1f       	adc	r21, r21
 d0a:	44 0f       	add	r20, r20
 d0c:	55 1f       	adc	r21, r21
 d0e:	48 0f       	add	r20, r24
 d10:	59 1f       	adc	r21, r25
 d12:	da 01       	movw	r26, r20
 d14:	a2 5b       	subi	r26, 0xB2	; 178
 d16:	b8 4f       	sbci	r27, 0xF8	; 248
 d18:	11 96       	adiw	r26, 0x01	; 1
 d1a:	ed 91       	ld	r30, X+
 d1c:	fc 91       	ld	r31, X
 d1e:	12 97       	sbiw	r26, 0x02	; 2
 d20:	02 80       	ldd	r0, Z+2	; 0x02
 d22:	f3 81       	ldd	r31, Z+3	; 0x03
 d24:	e0 2d       	mov	r30, r0
 d26:	12 96       	adiw	r26, 0x02	; 2
 d28:	fc 93       	st	X, r31
 d2a:	ee 93       	st	-X, r30
 d2c:	11 97       	sbiw	r26, 0x01	; 1
 d2e:	4f 5a       	subi	r20, 0xAF	; 175
 d30:	58 4f       	sbci	r21, 0xF8	; 248
 d32:	e4 17       	cp	r30, r20
 d34:	f5 07       	cpc	r31, r21
 d36:	29 f4       	brne	.+10     	; 0xd42 <vTaskSwitchContext+0x9c>
 d38:	42 81       	ldd	r20, Z+2	; 0x02
 d3a:	53 81       	ldd	r21, Z+3	; 0x03
 d3c:	fd 01       	movw	r30, r26
 d3e:	52 83       	std	Z+2, r21	; 0x02
 d40:	41 83       	std	Z+1, r20	; 0x01
 d42:	fc 01       	movw	r30, r24
 d44:	ee 0f       	add	r30, r30
 d46:	ff 1f       	adc	r31, r31
 d48:	ee 0f       	add	r30, r30
 d4a:	ff 1f       	adc	r31, r31
 d4c:	ee 0f       	add	r30, r30
 d4e:	ff 1f       	adc	r31, r31
 d50:	8e 0f       	add	r24, r30
 d52:	9f 1f       	adc	r25, r31
 d54:	fc 01       	movw	r30, r24
 d56:	e2 5b       	subi	r30, 0xB2	; 178
 d58:	f8 4f       	sbci	r31, 0xF8	; 248
 d5a:	01 80       	ldd	r0, Z+1	; 0x01
 d5c:	f2 81       	ldd	r31, Z+2	; 0x02
 d5e:	e0 2d       	mov	r30, r0
 d60:	86 81       	ldd	r24, Z+6	; 0x06
 d62:	97 81       	ldd	r25, Z+7	; 0x07
 d64:	90 93 73 07 	sts	0x0773, r25
 d68:	80 93 72 07 	sts	0x0772, r24
 d6c:	20 93 18 07 	sts	0x0718, r18
 d70:	08 95       	ret

00000d72 <_exit>:
 d72:	f8 94       	cli

00000d74 <__stop_program>:
 d74:	ff cf       	rjmp	.-2      	; 0xd74 <__stop_program>
